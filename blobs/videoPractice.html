<!DOCTYPE html>
<html >
  <head>
    <meta charset="UTF-8">
    <title>Gelly circle</title>

        <link rel="stylesheet" href="style.css">
    
  </head>

  <body>

    <canvas id="c" style="position: absolute"></canvas>

    <script src='../shared/utils.js'></script>

	<div id="container">
	    <video autoplay="true" id="videoElement">
	     
	    </video>
	</div>
	<script>
		var video = document.querySelector("#videoElement");
		 
		navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia;
		 
		if (navigator.getUserMedia) {       
		    navigator.getUserMedia({video: true}, handleVideo, videoError);
		}
		 
		function handleVideo(stream) {
		    video.src = window.URL.createObjectURL(stream);
		}
		 
		function videoError(e) {
		    // do something
	}
	</script>

	<script src='https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js'></script>
	<script src='matter.js'></script>
	<script src='https://s3-us-west-2.amazonaws.com/s.cdpn.io/39394/Degas.min.js'></script>

	<script>

			document.addEventListener('DOMContentLoaded', function(){
			    var v = document.getElementById('videoElement');

			    console.log(v.width);
			    console.log(v.height);

			    var canvas = document.getElementById('c');
			    var context = canvas.getContext('2d');
			    //var back = document.createElement('canvas');
			    var back = document.getElementById('d');
			    var backcontext = back.getContext('2d');

			    var cw,ch;
	    
		        cw = v.clientWidth;
		        ch = v.clientHeight;
		        console.log(cw);
		        console.log(ch);
		        canvas.width = cw;
		        canvas.height = ch;
		        back.width = cw;
		        back.height = ch;
		        draw(v,context,backcontext,cw,ch);


			},false);

			var backgroundPixels;

			function resetBackground() {
			  backgroundPixels = undefined;
			}

		    function draw(v,c,bc,w,h) {

		    	var naheeArray = [];
			    // First, draw it into the backing canvas
			    bc.drawImage(v,0,0,w,h);
			    // Grab the pixel data from the backing canvas
			    var idata = bc.getImageData(0,0,w,h);
			    var data = idata.data;
			    // Loop through the pixels, turning them grayscale

			    if(!backgroundPixels) {
			      backgroundPixels = copyImage(data, backgroundPixels);
			    }

			    var i = 0;
			    var thresholdAmount = 50 * 255. / 100.;
			    var thresholdType = 'rgb';
			    if(thresholdType === 'rgb') {
			      for(var y = 0; y < h; y++) {
			        for(var x = 0; x < w; x++) {
			          	data[i] = data[i] - backgroundPixels[i] > thresholdAmount ? 255 : 0; i++;
			          	data[i] = data[i] - backgroundPixels[i] > thresholdAmount ? 255 : 0; i++;
			          	data[i] = data[i] - backgroundPixels[i] > thresholdAmount ? 255 : 0; i++;
			          	i++;  // skip alpha
			          	if(y>h/2){
			          		if (i%120==0){
				          		naheeArray.push({ 'x': x, 'y': y });
			          		}
			          	}
			        }
			      }
			    }else if (thresholdType === 'bw') {
			      var total = 0;
			      for(var y = 0; y < h; y++) {
			        for(var x = 0; x < w; x++) {
			          // another common type of background thresholding uses absolute difference, like this:
			          // var total = Math.abs(pixels[i+0] - backgroundPixels[i+0] > thresholdAmount) || ...
			          var rdiff = Math.abs(data[i+0] - backgroundPixels[i+0]) > thresholdAmount;
			          var gdiff = Math.abs(data[i+1] - backgroundPixels[i+1]) > thresholdAmount;
			          var bdiff = Math.abs(data[i+1] - backgroundPixels[i+1]) > thresholdAmount;
			          var anydiff = rdiff || gdiff || bdiff;
			          var output = 0;
			          if(anydiff) {
			            output = 255;
			            total++;
			          }
			          data[i++] = output;
			          data[i++] = output;
			          data[i++] = output;
			          i++; // skip alpha
			        }
			      }
			      var n = w * h;
			      var ratio = total / n;
			      //select('#presence').elt.innerText = int(100 * ratio); 
			    }else {
			      for(var y = 0; y < h; y++) {
			        for(var x = 0; x < w; x++) {
			          data[i] = data[i] - backgroundPixels[i]; i++;
			          data[i] = data[i] - backgroundPixels[i]; i++;
			          data[i] = data[i] - backgroundPixels[i]; i++;
			          i++; // skip alpha
			        }
			      }
			    }

			    idata.data = data;
			    // Draw the pixels onto the visible canvas
			    //c.putImageData(idata,0,0);
			    // Start over!
			    ready(naheeArray);
			    setTimeout(function(){ draw(v,c,bc,w,h); }, 0);
			    //console.log(naheeArray.length);
			}



			var c, d, baseColor;
			var pPoints = [];
			var bPoints = [];

			var balles = [];
			var blobs = [];

			var dummyArray = [];
			var maxSphere = 10;
			var mainCircleRadius = 100;
			var mainCircleCenter = { 'x': window.innerWidth/2, 'y': window.innerHeight/2 };
			var engine;
			var mouse;
			var mousePos = { 'x': 0, 'y': 0 } ;
			var mainAnchor;

			// Matter.js module aliases
			var Engine = Matter.Engine,
			   World = Matter.World,
			   Body = Matter.Body,
			   Bodies = Matter.Bodies,
			   Composites = Matter.Composites,
			   Composite = Matter.Composite,
			   Constraint = Matter.Constraint;

			$(document).ready(function(){
			 engine = Engine.create(document.body, { render: { options: { wireframes: true } } });
			 engine.world.gravity.y = 0;
			 resize( window.innerWidth, window.innerHeight );

			 mainAnchor = Bodies.circle(window.innerWidth/2, window.innerHeight/2, 5);
			 mainAnchor.isStatic = true;
			 mainAnchor.groupId = 8;

			 createBalls();
			 createBlobs(dummyArray);
			 

			  World.add( engine.world, [ mouse, mainAnchor ] );

			  // run the engine
			  Engine.run(engine); 


			  c = $('#d')[0]; 
			  c.width = window.innerWidth;
			  c.height = window.innerHeight;

			  d = new Degas( c );

			  baseColor = "#f2f2f2";
			  p = new Degas.Path( pPoints );
			  p.stroke = baseColor;
			  p.fill = baseColor;
			  p.smoothPointsNumber = 20;
			  p.closed = true;
			  p.smooth();

			  b = new Degas.Path( bPoints );
			  b.stroke = baseColor;
			  b.smoothPointsNumber = 20;
			  b.closed = true;
			  b.smooth();

			  d.addChild( p );
			  d.addChild( b );	 
			  
			  $(window).resize(function(){
			    resize( window.innerWidth, window.innerHeight );
			    d.resize();
			  });
			});

			function ready(arr){

				if (arr.length>0){
					mousePos.x = arr[0].x;
					mousePos.y = arr[0].y;
					//console.log(arr[0]);
				}else{
					   mousePos.x = 200;
					   mousePos.y = 200;
				}

				loop(arr);

				engine.render.canvas.style.opacity = 10;
			} 

			function resize( width, height ){
			 engine.world.bounds.max = { x: width, y: height };
			 engine.render.canvas.width = width;
			 engine.render.canvas.height = height;
			 engine.render.canvas.style.width = width + 'px';
			 engine.render.canvas.style.height = height + 'px';
			}

			function createConstrainteObjObj( ba, bb, stiffness ){ 
			 return Constraint.create({ bodyA: ba, bodyB: bb, stiffness: stiffness||0.05 }) 
			}

			function createConstrainteObjPts( ba, pa, stiffness ){ 
			 return Constraint.create({ bodyA: ba, pointB: pa, stiffness: stiffness||0.05 }) 
			}

			function loop(arr){
				requestAnimationFrame( loop );
			 //mouse.position = mousePos;

			 if (arr.length>0){
					/*mousePos.x = arr[0].x;
					mousePos.y = arr[0].y;*/
					mousePos.x = 360;
					mousePos.y = 360;
					//console.log(naheeArray[0]);
				}

			 //Body.translate( mouse, { x: mousePos.x - mouse.positionPrev.x,  y: mousePos.y - mouse.positionPrev.y} );

			 for( var i = 0; i < balles.length; i++ ){
			   p.points[i].x = balles[i].position.x;
			   p.points[i].y = balles[i].position.y
			 }

			 for( var j = 0; j < blobs.length; j++ ){
			   b.points[j].x = blobs[j].position.x;
			   b.points[j].y = blobs[j].position.y
			 }

			 d.render();

			 //bPoints = [];
				//createBlobs(arr);
			 createBlobs(arr);
			}

			function createBalls(){
			 for( var i = 0; i < maxSphere; i++ ){
			   var x = mainCircleRadius * Math.cos( Math.PI*2/maxSphere*i ) + window.innerWidth/2;
			   var y = mainCircleRadius * Math.sin( Math.PI*2/maxSphere*i ) + window.innerHeight/2;
			   var b = Bodies.circle( x, y, 20 );
			   balles.push( b );
			   World.add( engine.world, [ b ] );
			   World.add( engine.world, [ createConstrainteObjPts( b, { x: x, y: y} ) ] );

			   pPoints.push( new Degas.Point( x, y ) );
			 }
			}

			function createBlobs(arr){
				bPoints = [];
			 for( var j = 0; j < maxSphere; j++ ){
			 	/*if(arr.length > maxSphere){
			 		var x_b = mainCircleRadius * arr[j].x + window.innerWidth/2;
			   		var y_b = mainCircleRadius * arr[j].y + window.innerHeight/2+150;
			 	}else{
			 		var x_b = mainCircleRadius * Math.cos( Math.PI*2/maxSphere*j ) + window.innerWidth/2;
			   		var y_b = mainCircleRadius * Math.sin( Math.PI*2/maxSphere*j ) + window.innerHeight/2+150;
			 	}*/

		 		var x_b = mainCircleRadius * Math.cos( Math.PI*2/maxSphere*j ) + window.innerWidth/2;
		   		var y_b = mainCircleRadius * Math.sin( Math.PI*2/maxSphere*j ) + window.innerHeight/2+150;
			   
			   mouse = Bodies.circle(x_b, y_b, 20);
			   mouse.groupId = 8;
			   blobs.push( mouse );
			   World.add( engine.world, [ mouse ] );
			   World.add( engine.world, [ createConstrainteObjPts( mouse, { x: x_b, y: y_b} ) ] );

			   bPoints.push( new Degas.Point( x_b, y_b ) );
			 }
			 
			}

	</script>

	<canvas id="d" style="position: absolute"></canvas>
	
	<!--<script src="index.js"></script>-->
	

	    
  </body>
</html>