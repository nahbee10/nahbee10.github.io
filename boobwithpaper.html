<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Animated Star</title>
    <link rel="stylesheet" href="style.css">
    <script type="text/javascript" src="paper-full.js"></script>
    <script type="text/paperscript" canvas="canvas">
		var point = new Point(view.size.width/2-50, view.size.height/2-390);
		var point2 = new Point(view.size.width/2+50, view.size.height/2-390);

		var radius = 240;
		var radius_tit = 20;

		var boundOffset = [];
		var boundOffsetBuff = [];
		var sidePoints = [];
		var boundOffset2 = [];
		var boundOffsetBuff2 = [];
		var sidePoints2 = [];
		var boundOffset_tit = [];
		var boundOffsetBuff_tit = [];
		var sidePoints_tit = [];
		var boundOffset_tit2 = [];
		var boundOffsetBuff_tit2 = [];
		var sidePoints_tit2 = [];

		var numSegment = Math.floor(radius / 3 + 2);
		var numSegment_tit = Math.floor(radius_tit / 10 + 9);

		var path = new Path({
			fillColor: new Color(205/255,142/255,109/255),

		});

		var path2 = new Path({
			fillColor: new Color(205/255,142/255,109/255),

		});

		var path_tit = new Path({
			fillColor: new Color(144/255,109/255,107/255),

		});

		var path_tit2 = new Path({
			fillColor: new Color(144/255,109/255,107/255),

		});

		var mouseMPoint = new Point();

		for (var i = 0; i < numSegment; i ++) {
			boundOffset.push(radius);
			boundOffsetBuff.push(radius);
			boundOffset2.push(radius);
			boundOffsetBuff2.push(radius);

			path.add(new Point());
			path2.add(new Point());
			sidePoints.push(new Point({
				angle: (90 / numSegment * i) + 60,
				length: Math.sin((180 / numSegment * i)*(Math.PI/180))
			}));
			sidePoints2.push(new Point({
				angle: (90 / numSegment * i) + 30,
				length: Math.sin((180 / numSegment * i)*(Math.PI/180))
			}));

		}

		for (var j = 0; j < numSegment_tit; j ++) {
		    
			boundOffset_tit.push(radius_tit);
			boundOffsetBuff_tit.push(radius_tit);
			boundOffset_tit2.push(radius_tit);
			boundOffsetBuff_tit2.push(radius_tit);

			path_tit.add(new Point());
			path_tit2.add(new Point());

			sidePoints_tit.push(new Point({
				angle: 180 / numSegment_tit * j+19,
				length: 1
			}));
			sidePoints_tit2.push(new Point({
				angle: 180 / numSegment_tit * j-15,
				length: 1
			}));
			
		}



		function onMouseMove(event) {
			mouseMPoint = event.point;
		}

		var minusPt = new Point(0,10);
		var point_tit = getSidePoint(point, 40, sidePoints, boundOffset) - minusPt;
		var point_tit2 = getSidePoint(point2, 40, sidePoints2, boundOffset2) - minusPt;

		function iterate() {
		    
		    point_tit = getSidePoint(point, 40, sidePoints, boundOffset) - minusPt;
		    point_tit2 = getSidePoint(point2, 40, sidePoints2, boundOffset2) - minusPt;
			updateShape(point, path, boundOffset, boundOffsetBuff, sidePoints, numSegment, radius);
		    updateShape(point2, path2, boundOffset2, boundOffsetBuff2, sidePoints2, numSegment, radius);
		    updateShape(point_tit, path_tit, boundOffset_tit, boundOffsetBuff_tit, sidePoints_tit, numSegment_tit, radius_tit);
		    updateShape(point_tit2, path_tit2, boundOffset_tit2, boundOffsetBuff_tit2, sidePoints_tit2, numSegment_tit, radius_tit);
			//updateShape(path2);
			//console.log(mouseMPoint);
		}

		function updateShape(pt, pth, bOSet, bOSetBuff, sP, nS, rad){

			var segments = pth.segments;
			for (var i = 0; i < nS; i ++)
				segments[i].point = getSidePoint(pt, i, sP, bOSet);

			pth.smooth();
			
			//console.log(path);

			for (var i = 0; i < nS; i ++) {
				if (bOSet[i] < rad / 4)
					bOSet[i] = rad / 4;
				var next = (i + 1) % nS;
				var prev = (i > 0) ? i - 1 : nS - 1;
				var offset = bOSet[i];
				offset += (rad - offset) / 2;
				offset += ((bOSet[next] + bOSet[prev]) / 2 - offset) / 1.5;
				bOSetBuff[i] = bOSet[i] = offset;
			}
		}

		function react(pt, bOSet, bOSetBuff, sP, nS, rad) {

			var dist = pt.getDistance(mouseMPoint);
			if (dist < rad && dist != 0) {
				var overlap = rad - dist;
				//var direc = (point - this.mouseE).normalize(overlap * 0.015);
				//this.vector += direc;
				//b.vector -= direc;

				calcBounds(pt, mouseMPoint, bOSet, bOSetBuff, sP, nS);
				//b.calcBounds(this);
				updateBounds(bOSet, bOSetBuff, nS);
				//b.updateBounds();
			}
		}


		function getBoundOffset(b, bOSet) {
			var diff = b - mouseMPoint;
			//console.log(diff);
			var angle = (diff.angle + 240) % 360;
			return bOSet[Math.floor(angle / 360 * bOSet.length)];
		}

		function calcBounds(pt, b, bOSet, bOSetBuff, sP, nS) {
			for (var i = 0; i < nS; i ++) {
			    //console.log(tp);
				var tp = getSidePoint(pt, i, sP, bOSet);
				var bLen = getBoundOffset(tp, bOSet);
				var td = tp.getDistance(b);
				if (td < bLen) {
					bOSetBuff[i] -= (bLen  - td) / 24;
				}
			}
		}

		function getSidePoint(pt, index, sP, bOSet) {
			return pt + sP[index] * bOSet[index];
		}

		function updateBounds(bOSet, bOSetBuff, nS) {
			for (var i = 0; i < nS; i ++)
				bOSet[i] = bOSetBuff[i];
		}

		//--------------------- main ---------------------

		function onFrame() {
			react(point, boundOffset, boundOffsetBuff, sidePoints, numSegment, radius);
			react(point2, boundOffset2, boundOffsetBuff2, sidePoints2, numSegment, radius);
			react(point_tit, boundOffset_tit, boundOffsetBuff_tit, sidePoints_tit, numSegment_tit, radius_tit);
			react(point_tit2, boundOffset_tit2, boundOffsetBuff_tit2, sidePoints_tit2, numSegment_tit, radius_tit);
			iterate();

		}
    </script>
</head>
<body>
    <canvas id="canvas" resize stats hidpi="off"></canvas>
</body>
</html>